#!meta

{"kernelInfo":{"defaultKernelName":"fsharp","items":[{"name":"csharp","languageName":"C#","aliases":["c#","cs"]},{"name":"fsharp","languageName":"fsharp"},{"name":"html","languageName":"HTML"},{"name":"http","languageName":"HTTP"},{"name":"javascript","languageName":"JavaScript","aliases":["js"]},{"name":"mermaid","languageName":"Mermaid"},{"name":"pwsh","languageName":"PowerShell","aliases":["powershell"]},{"name":"value"}]}}

#!fsharp

//#!import "ModifyFsProjectToGeneratePackage.dib"

#!fsharp

#r "nuget: BallerinaCore,1.0.0-beta.169.1224"
#r "nuget: TryBallerina,1.0.0-beta.169.2059"

#!fsharp

Env.BLP_INPUT_FORMS_DIR.Value

#!fsharp

type T = FileSystem<Env.BLP_INPUT_FORMS_DIR.Value>
T.``dispatch-person-config.json`` |> makeStrong 

#!fsharp

dispatch_person_config.Types.SapConfig.Fun

#!fsharp

#!faker --lang ru
faker.Internet.UserName()
#!faker --lang en
faker.Internet.UserName()
#!faker --lang pl
faker.Internet.UserName()

#!fsharp

sum {
    let! _m, _p = IDE.Parser.parse dispatch_person_config_content
    return _p.Value.Types.Keys.Count
} |> Sum.toOption |> Option.get

#!fsharp

let fakePrimitive =
    function
    | PrimitiveType.StringType -> faker.Name.FullName()                 |> Value.ConstString 
    | PrimitiveType.IntType -> Random().Next(1, 1000)                   |> Value.ConstInt
    | PrimitiveType.FloatType -> Random().NextDouble() |> decimal       |> Value.ConstFloat
    | PrimitiveType.BoolType -> Random().Next(0, 1) = 1                 |> Value.ConstBool
    | PrimitiveType.GuidType -> System.Guid.NewGuid()                   |> Value.ConstGuid
    | PrimitiveType.DateTimeType
    | PrimitiveType.DateOnlyType ->  System.DateTime.Now.AddDays(Random().Next(-365, 365)) |> string |> Value.ConstString //Todo
    //| missing_def -> failwith $"Unsupported primitive type for fake data generation {missing_def}"

#!fsharp

let typeContext =

    sum {
        let! _m, _p = IDE.Parser.parse dispatch_person_config_content
        return _p.Value.Types
    } 
    |> Sum.toOption 
    |> Option.get

#!fsharp

let rec look (expr: ExprTypeId) (context: TypeContext) =
  context
  |> Map.tryFind expr.TypeName
  |> Option.orElse  (context |> Map.tryPick ( fun key value -> look value.TypeId context))

#!fsharp

look { TypeName = "Birthday"} typeContext

#!fsharp

//todo: change to something that is optimasied for a tail position processing
let rec traverse (tc: TypeContext) sum name (t: ExprType) =
    sum + 
    match t with
    | UnitType -> "()"
    | CustomType s -> s 
    | VarType s -> sum + $""" "{s.VarName}" """
    | LookupType s -> "Lookup for " + s.TypeName
    | PrimitiveType pt -> sum +  $"{fakePrimitive pt}"
    | RecordType m -> 
        let fields = m |> Map.toList |> List.map (fun (k, v) -> $""" {{ "{k}": "{traverse tc sum name v}" }}""")
        (fields |> String.concat ", ")
    | UnionType m -> 
        let fields = m |> Map.toList |> List.map (fun (k, v) -> k.CaseName, traverse tc sum name v.Fields)
        "UnionType: " + (fields |> List.map (fun (k, v) -> k + ": " + v) |> String.concat ", ")
    | MapType (expr1, expr2) -> (traverse tc name sum expr1) + (traverse tc name sum expr2)
    | SumType (expr1, expr2) -> (traverse tc name sum expr1) + (traverse tc name sum expr2)
    | TupleType exprs -> 
        let fields = exprs |> List.map (traverse tc name sum) |> List.toArray
        sum + $"""[ {System.String.Join(',', fields)}]""" // (fields |> String.concat ", ")
    | OptionType expr -> (traverse tc name sum expr)
    | OneType expr -> (traverse tc name sum expr)
    | ManyType expr -> (traverse tc name sum expr)
    | ListType expr -> $"[{traverse tc name sum expr}]"
    | TableType expr -> (traverse tc name sum expr)
    | SetType expr -> (traverse tc name sum expr)
    | ArrowType (expr1, expr2) -> (traverse tc name sum expr1) + (traverse tc name sum expr2)
    | GenericType (exprTypeId, exprTypeKind, exprType) -> traverse tc name sum exprType
    | GenericApplicationType (expr1, expr2) -> (traverse tc name sum expr1) + (traverse tc name sum expr2)
   

#!fsharp

typeContext
|> Map.find "Person"
|> (fun k -> 
    string k
)

#!fsharp

typeContext
|> Map.find "Person"
|> (fun k -> 
    traverse typeContext "" k.TypeId.TypeName k.Type
)

#!fsharp

open Ballerina.DSL.Expr

#!fsharp

{| x = 42; y = 42 |}.x

#!fsharp

Unary (UnaryOperator.Minus, VarLookup { VarName = "abc"})

#!fsharp

MakeCase ("x", VarLookup { VarName = "abc"})

#!fsharp

#!forms --input multi-renderers.json --output generated-output/models --codegenConfigPath go-config.json
